"use strict";(self.webpackChunkef_website_template=self.webpackChunkef_website_template||[]).push([[870],{7750:e=>{e.exports=JSON.parse('{"blogPosts":[{"id":"/2023/01/23/finaler-blogbeitrag-numtrip","metadata":{"permalink":"/ef_info/2023/01/23/finaler-blogbeitrag-numtrip","editUrl":"https://github.com/No0ne155/ef_info/tree/main/blog/2023-01-23-finaler-blogbeitrag-numtrip.md","source":"@site/blog/2023-01-23-finaler-blogbeitrag-numtrip.md","title":"Finaler Blogbeitrag NumTrip","description":"Seit der erstellung des NumTrip.py games am 16. September 2022 arbeiteten wir immer wieder an diesem NumTrip Spiel. Doch was ist das \xfcberhaupt?","date":"2023-01-23T00:00:00.000Z","formattedDate":"23. Januar 2023","tags":[],"readingTime":4.635,"hasTruncateMarker":false,"authors":[],"frontMatter":{},"nextItem":{"title":"Arbeiten am Numtrip","permalink":"/ef_info/2022/12/02/arbeiten-am-numtrip"}},"content":"Seit der erstellung des NumTrip.py games am 16. September 2022 arbeiteten wir immer wieder an diesem NumTrip Spiel. Doch was ist das \xfcberhaupt?\\n## Das Spiel\\nZiel des Spieles *NumTrip* ist es, ein Feld mit dem Wert 128 (oder eine andere selbst festgelegte zweierpotenz) zu erreichen. Zum beginn hat man nur ein Feld mit zuf\xe4lligen zweierpotenzen. Indem man koordinaten des Feldes aussucht, das Nachbarfelder mit dem gleichen Wert hat, kann man den Wert dieses Feldes verdoppeln, und die umliegenden Felder verschwinden lassen. Nun generieren oben am Feld neue Zahlen. So kann man versuchen, die Felder so lange zu kombinieren, bis man 128 erreicht hat. So **gewinnt** man das Spiel.\\n\\nJedoch kann man auch verlieren. Wenn es keine Felder mehr gibt, die man kombinieren kann, hat man **Verloren**.\\n\\n## Umsetzung\\n### Voraussetzungen\\nUm meine Version des NumTrip zu spielen, braucht man eine Applikation (z.b. VisualStudioCode) um ein Python Programm laufen zu lassen. Unsere verwendete Python Version ist *Python 3.10.6*. Meinen Code findet man auf [GitHub](https://github.com/No0ne155/ef_info/blob/main/NumTrip/NumTrip_FINAL.py) Diesen kann man in ein Dokument in VSCode kopieren, dass die endung `.py` hat. Damit definiert man, dass es ein Python Dokument ist. \\n### Top-Down Entwurf\\nUm ein Grosses Projekt besser erf\xfcllen zu k\xf6nnen, verwendet man einen sogenannten Top-Down entwurf. Mein Top-Down Entwurf hat auf der Obersten Ebene das NumTrip-Game. Dies teilt man nun in immer kleinere Teilprobleme auf, bis man viele kleine dinge hat, die einfacher sind. Diese f\xfcgt man dann zusammen, damit man ein komplettes Projekt hat.\\n![](./images/topdown.png)\\nz.b. im Bereich Feld, habe ich f\xfcr das Generieren des Feldes die Funktion `generatefield()` erstellt. Diese Funktion generiert zufallszahlen, und f\xfcgt die in die `spielfeld` Liste. F\xfcr das Ausgeben des Feldes habe ich die Funktion `printfield()` erstellt. Diese Druckt das Design des Spielfeldes, und entsprechend der gr\xf6sse der Zahl, wird die Funktion so angepasst, dass das Design nicht durcheinander kommt. Diese beiden Funktionen zusammen ergeben das Spielfeld. Zum schluss werden die funktionen an der richtigen Stelle im Code oder in anderen Funktionen aufgerufen. So \xe4hnlich funktioniert es auch mit allen anderen Teilbereichen die im Top-Down entwurf geschrieben sind.\\n### Konzept Nachbarpr\xfcfung\\nIm Spiel verwende ich viele sogenannte Algorithmen. Einer davon wird z.b. f\xfcr die \xfcberpr\xfcfung ob eine Nachbarzelle vorhanden ist eingesetzt. Die Funktion wird ben\xf6tigt, denn wir wollen die zahl ja nur verdoppeln, wenn sie auch mindestens ein Feld rundherum hat, dass den gleichen Wert hat. Daf\xfcr erstellen wir die folgende Funktion: `validateneighbour(y, x)` Dabei sind `y` und `x` Parameter die man beim Aufrufen der funktion mitgibt. In diesem fall entsprechen die Parameter den Koordinaten im Spielfeld. Die Parameter sind in der gew\xe4hlten Reihenfolge, da `y` f\xfcr die Zeile steht, und `x` f\xfcr die Spalte.\\n\\nBeim Aufrufen der Funktion wird \xfcberpr\xfcft, ob die Funktion `True` zur\xfcckgibt. Nun muss die funktion `True` zur\xfcckgeben, wenn ein Nachbar vorhanden ist, sonst muss `False` zur\xfcckgegeben werden. Im ersten schritt pr\xfcfen wir ob in die `x-1` richtung ein Nachbar ist. Damit kein List-Index ERROR erscheint, pr\xfcfen wir, ob die Zahl gr\xf6sser als `1` ist, da wir `1` subtrahieren, und nicht ins Negative wollen. Diese \xfcberpr\xfcfung findet mit \\n``` py \\nif x >= 1:\\n```\\nstatt. Wenn dieses Statement zutrifft, geht es weiter zur \xfcberpr\xfcfung, ob die ausgew\xe4hlten Koordinaten den gleichen Wert gespeichert haben, wie die selbe Koordinate aber mit `x-1`. \\n```py\\nif spielfeld[x-1][y] == spielfeld[x][y]:\\n            return True   \\n```\\nDies wird nun in alle anderen Richtungen genau gleich angewendet. Nat\xfcrlich mit anderen werten.\\nWenn nie ein Feld den gleichen Wert hat, wird zum schluss `False` zur\xfcckgegeben.Gesamt sieht der Algorithmus dann so aus:\\n```py\\ndef validateneighbour(y,x):\\n    if x >= 1: \\n        if spielfeld[x-1][y] == spielfeld[x][y]: \\n            return True                          \\n    if x <= 3:\\n        if spielfeld[x+1][y] == spielfeld[x][y]:\\n            return True\\n    if y >= 1:\\n        if spielfeld[x][y-1] == spielfeld[x][y]:\\n            return True\\n    if y <= 3:\\n        if spielfeld[x][y+1] == spielfeld[x][y]:\\n            return True\\n    return False\\n```\\n## Probleme\\nMein gr\xf6sstes Problem war, dass ich gewisse funktionen so aufbaute, dass sie Funktionierten, aber nicht mit k\xfcnftigen Funktionen kompatibel waren. So kam ich oft an den Punkt, dass ich vieles \xfcberarbeiten musste, da ich fr\xfcher nicht gut genug arbeitete.\\n\\nEs kam sogar so weit, dass ich Fehler hatte, nicht wusste woher, die Logik keinen Sinn mehr ergab, so dass ich mich entschied, von vorne anzufangen. Ich verwendete nat\xfcrlich gewisse funktionen wieder, aber ich fing wieder von 0 an, damit ich alles nochmals Schritt f\xfcr Schritt durchgehen kann. Z.b. f\xfcgte ich in der `printfield()` funktion die neuen, angepassten Strings (der Zahlenwert mit passender anzahl leerzeichen) HINTEN an die Liste, l\xf6schte sie jedoch nie, weshalb sich mein Spielfeld nicht Ver\xe4nderte, egal was ich als Input gab. Solche kleine Fehler w\xe4ren mir sonst nicht aufgefallen.\\n\\n## Tipps:\\nWenn du auch so ein Programm schreibst, \xfcberleg dir manchmal zuerst, was du sp\xe4ter auch noch in die Funktion einf\xfcgen musst, damit du sie Sp\xe4ter nicht nochmals schreiben musst. \\n\\nEbenfalls ist es hilfreich, wenn du deinen Funktionen und Variabeln namen gibst, die dir Klar machen, was sie tun, sodass du den \xdcberblick beh\xe4lst. Aber mach die Namen auch nicht zu lange, denn es kann sehr m\xfchsam sein, den namen `spielfeldnice[playerinputY][playerinputX]` in einer Funktion 4 mal zu schreiben.\\n\\n## Fazit\\nMit mehr Zeit, w\xe4ren noch viele Features mehr m\xf6glich gewesen. Da man aber nicht immer viel Zeit hat, sich die Zeit nicht nimmt, oder ein Problem hat, dass sich einfach nicht l\xf6sen will, bin ich ganz zufrieden mit meinem Resultat. Am Anfang stockte es, doch als ich im Neugeschriebenen Programm (fast) alle Probleme gefunden hatte, ging alles sehr schnell. Weitere Features zu implementieren w\xe4ren nicht die Komplizierteste sache, jedoch muss man es machen, und nicht nur dar\xfcber Nachdenken\\n\\nAllem in allem war es ein Tolles Projekt."},{"id":"/2022/12/02/arbeiten-am-numtrip","metadata":{"permalink":"/ef_info/2022/12/02/arbeiten-am-numtrip","editUrl":"https://github.com/No0ne155/ef_info/tree/main/blog/2022-12-02-arbeiten-am-numtrip.md","source":"@site/blog/2022-12-02-arbeiten-am-numtrip.md","title":"Arbeiten am Numtrip","description":"Besprechung Benutzereingaben","date":"2022-12-02T00:00:00.000Z","formattedDate":"2. Dezember 2022","tags":[],"readingTime":1.52,"hasTruncateMarker":false,"authors":[],"frontMatter":{},"prevItem":{"title":"Finaler Blogbeitrag NumTrip","permalink":"/ef_info/2023/01/23/finaler-blogbeitrag-numtrip"},"nextItem":{"title":"Wiedereinstieg Python","permalink":"/ef_info/2022/08/26/wiedereinstieg-python"}},"content":"## Besprechung Benutzereingaben\\n\\nIch verglich mit Thomas den Code, und wir beide verwenden ein sehr \xe4hnliches system, was die Besprechung kurz hielt.\\n\\n## Arbeiten Numtrip\\nAls erstes habe ich den Auftrag gelesen, und ausgef\xfchrt.\\nIch passte das Programm von Wikipedia auf mein Programm an. Der Code sah wie folgt aus:\\n```\\ndef checkandremove(x, y, oldvalue, newvalue):\\n    if spielfeld[x][y] == oldvalue:\\n        spielfeld[x][y] = newvalue\\n        checkandremove(x,y+1,oldvalue,newvalue)\\n        checkandremove(x,y-1,oldvalue,newvalue)\\n        checkandremove(x+1,y,oldvalue,newvalue)\\n        checkandremove(x-1,y,oldvalue,newvalue)\\n        game()\\n```\\nNach ein paar tests bemerkte ich, dass wenn z.b. `x` bereits `4` ist, und dann `x+1` \xfcberpr\xfcft wird, dies ausserhalb der liste ist. Deshalb \xe4nderte ich den code zu dem:\\n```\\ndef checkandremove(x, y, oldvalue, newvalue):\\n    if spielfeld[x][y] == oldvalue:\\n        spielfeld[x][y] = newvalue\\n        if y+1 <= 4:\\n            checkandremove(x,y+1,oldvalue,newvalue)\\n        if y-1 >= 0:\\n            checkandremove(x,y-1,oldvalue,newvalue)\\n        if x+1 >= 0:\\n            checkandremove(x+1,y,oldvalue,newvalue)\\n        if x-1 <= 4:\\n            checkandremove(x-1,y,oldvalue,newvalue)\\n        game()\\n```\\nNach weiteren Tests, fiel mir noch ein gr\xf6sseres noch nicht gel\xf6stes Problem auf.\\n\\n![](images/numtrip_problem0.png)\\n\\nNehmen wir dieses Feld. Wenn nun der Player den input `X = 1, Y = 1` eingibt, kommt dieses Feld heraus:\\n\\n![](images/numtrip_problem1.png)\\n\\nIch fragte mich warum. Nach dem Betrachten des Codes wusste ich es.\\nAuf dieser Darstellung zeige ich es.\\n\\n![](images/numtrip_problem2.png)\\n\\nAls erstes wird von `1, 1` aus nach rechts gepr\xfcft. Auf diesem Feld wird dann als n\xe4chstes nach unten gepr\xfcft, und danach nach rechts (wo kein passendes Feld ist), und danach nach links, wo die letzte 4 ist, die entfernt wird. Von diesem Feld aus wird nun in alle richtungen \xfcberpr\xfcft, jedoch keine 4 mehr entdeckt. Die auf dem Bild Blau markierten Pfeile sollten noch gepr\xfcft und entfernt werden, dies passiert jedoch nicht, aufgrund der reihenfolge im code.\\n\\nIch \xfcberlegte den rest der Zeit noch daran, fand jedoch keine L\xf6sung f\xfcr den Code. Jedoch kann man dieses Beispiel l\xf6sen, indem der Spieler die Position `X = 0, Y = 3` w\xe4hlt.\\n\\n### L\xf6sung wird gesucht!!!"},{"id":"/2022/08/26/wiedereinstieg-python","metadata":{"permalink":"/ef_info/2022/08/26/wiedereinstieg-python","editUrl":"https://github.com/No0ne155/ef_info/tree/main/blog/2022-08-26-wiedereinstieg-python.md","source":"@site/blog/2022-08-26-wiedereinstieg-python.md","title":"Wiedereinstieg Python","description":"Heute, beim 2. mal EF, haben wir wieder mit Python angefangen, und einen Theorieblock gehabt.","date":"2022-08-26T00:00:00.000Z","formattedDate":"26. August 2022","tags":[],"readingTime":0.685,"hasTruncateMarker":false,"authors":[],"frontMatter":{},"prevItem":{"title":"Arbeiten am Numtrip","permalink":"/ef_info/2022/12/02/arbeiten-am-numtrip"}},"content":"Heute, beim 2. mal EF, haben wir wieder mit Python angefangen, und einen Theorieblock gehabt.\\n## Theorieblock\\nIm Theorieblock haben wir __Programmiersprachen__ angeschaut. Vor allem wie sie aufgebaut sind in den __Sprachstufen__. Ich will nicht einfach die Website abschreiben, also hier der Link: [Programmiersprachen](https://ofi.gbsl.website/24ef/Programmieren/Programmiersprachen)\\n\\n## Python\\nWir haben angefangen mit __Turtle__ Python zu repetieren. Zum gl\xfcck ist noch mehr oder weniger alles Pr\xe4sent, jedoch gab es einige Tippfehler. Das liegt jedoch daran, dass die \xdcbung fehlt. Am meisten ging der `:` bei einer `for` Schleife vergessen. Am zweitmeisten passierte ein fehler beim tippen von `forward`, `left` oder `right`. Jedoch kann man ja einfach `fd`, `lt` oder `rt` verwenden, wodurch das sehr minimiert wurde. \\n\\n## Blog\\nAm schluss haben wir noch angefangen diesen Blog hier zu schreiben. Ich schreibe aber nicht gerne, weshalb er nicht sehr Kreativ ist."}]}')}}]);